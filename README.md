# JVM

### Описание принципа загрузчика классов(classloader)
Задача подгрузить класс JvmComprehension. Загрузчики классов передают друг другу запросы на загрузку Application class loader, Platform class loader, Bootstrap class loader. 
Загрузчик классов bootstrap , не имеет ClassLoader объекта, а скорее является частью собственного кода JVM. Далее пытается найти мой класс Platform class loader и затем Application class loader. В итоге класс JvmComprehension загружен Application class loader. Это видно на основании результатов команды System.out.println(JvmComprehension.class.getClassLoader());
Данная операция проделана на рисунке 1. Данный файл Figure 1 в приложении.


### Описание области памяти при работе приложения
По ходу описания я имею небольшие вопросы которые буду отмечать [?1], [?2] и т.д. Надеюсь на пояснение. Заранее спасибо.

еще до цифры //1 (т.е. 4-й строчки кода) при вызове метода main() в stack memory создается frame(фреймовый блок).
1 Во frame метода main(), int i = 1 сохраняется в ячейку KEY-VALUE, где KEY= i, VALUE = 1 и занимает 4 байта.
2 В heap memory создается объект Object, а затем в stack memory во frame для метода main записывается адрес "о" на Object с помощью стековых указателей. (По сути пустой Object занимает не знаю сколько байт[?1])
3 В heap memory создается объект Integer со значением 2 (2 записана в виде примитива), а затем во frame для метода main записывается адрес “ii” на данный объект. (Занимает для 64 разрядной системы: Заголовок: 16 байт. Поле int: 4 байта. Выравнивание для кратности:4 байта. Итого: 24 байта).
4 Создается frame для метода printAll. В данном frame создаются адреса на аргументы метода printAll, другими словами на следующие объекты: Object(находится в heap, уже создан) и на Integer со значением 2(находится в heap, уже создан). Также во frame для метода printAll создается ячейка KEY = i, VALUE = 1 (занимает 4 байта). Область видимости этого frame не пересекается с frame метода main.
5 создается объект Integer со значением 700 в heap(занимает аналогично предыдущему Integer: 24 байта). В stack memory во frame метода printAll создается адрес uselessVar на объект Integer в котором значение 700.
6 Создается frame метода println() в stack memory. В данном frame создается адрес на Object(уже находится в heap) и на Integer со значением 2(уже находится в heap). Также во frame для метода println создается ячейка KEY = i, VALUE = 1 (занимает 4 байта). Далее:
- Создается frame для метода toString(), там только ссылка на объект java.lang.Object@3feba861.
- Во frame для метода println() записывается ссылка на результат операции сложения, поскольку складываются объект Object и примитив int и объект Integer, результат сложения – объект. В результате в heap memory создается новый объект java.lang.Object@3feba86112. (Опять не понятно сколько занимает байт[?2]).
- Результат выводится в консоль. Данные затираются из памяти.
7 Создается frame для метода println(). В heap memory создается String pool состоящий из массива байт, где в каждой ячейке массива [f], [i], [n], [i], [s], [h], [e], [d](занимает 7 байт). Вывод в консоль, данные затираются.

### Сборщик мусора (Garbage collector) 
Пояснение на Рисунке 2. Рисунок 2(Figure 2) в приложении.
Итог пояснения приведу здесь.
Для небольшого приложения Garbage collector осуществил сборку мусора только по завершению работы. Иногда даже и не сразу осуществил, а только по прошествию некоторого времени поскольку операционная система, которая занимается анализом считала, что имеется достаточно ресурсов, и осучествлять чистку не целесообразно. 
